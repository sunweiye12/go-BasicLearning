package main

import "fmt"

/*
Goroutine 奉行通过通信来共享内存，而不是共享内存来通信。
Channel
	Channel 是 goroutine 沟通的桥梁，大都是阻塞同步的
	通过 make 创建，close 关闭
	Channel 是引用类型(所以可以直接传递)
	可以使用 for range 来迭代不断操作 channel
	可以设置单向或双向通道

---> 可以在声明的时候可以为一个通道设置缓存 <----
 无缓存的通道是同步阻塞的,对于无缓存的通道,当我们写入一个数据时,他是阻塞在那里,直到另外线程取出此值时才结束,继续向下运行  --> 写一个读一个
	(即默认缓存为 0,他不能够缓存,只有有人接收的时候,他才能够放的进去)
 有缓存的通道是异步的非阻塞执行,在未被填满之前是不会阻塞的,会进行异步调用,可以一边存一边取
	(相当于有地方可以放元素,可以线放进去,然后你再慢慢的取)

---> 在利用 channel 进行对线程传递任务的时候注意容易产生死锁,因此要记得 close 通道
*/

func main3() {

	//创建一个 channel 类型
	c := make(chan bool) // 通道中存储的类型为 bool 类型
	go func() {          // 执行匿名函数(将 true 存入沟道 c)
		fmt.Println("Go Go Go!!!")
		c <- true
		c <- false
		close(c)
		// 此处必须要调用 close()方法明确将通道关闭,否则外部的线程在使用此通道的时候,例如下面的程序进项循环遍历操作时
		// 就会一直进行遍历等待可能会加入通道的数据,从而产生死锁,只有当通道关闭以后,才会明确该所线程结束遍历
	}()

	// for range 来迭代不断操作 channel
	for v := range c {
		fmt.Println(v)
	}

}
